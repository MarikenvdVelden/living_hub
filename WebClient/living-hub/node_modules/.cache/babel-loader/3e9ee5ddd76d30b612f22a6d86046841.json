{"ast":null,"code":"function e(e, r, t) {\n  return e.length + 1 === r.length && r.endsWith(t);\n}\n\nfunction r(r, t) {\n  if (!t) return t;\n  var n = String(t).replace(/[^\\da-zA-Z\\n|]/g, \"\"),\n      l = r.split(/[^\\da-zA-Z\\n|]/g).filter(Boolean).map(function (e) {\n    return e.length;\n  }),\n      a = r.split(/[\\da-zA-Z\\n|]/g).filter(Boolean),\n      u = a[0],\n      c = a[a.length - 1];\n\n  if (r.startsWith(u)) {\n    var i = a.reduce(function (e, r, t) {\n      var n = l[t],\n          a = e.value.slice(0, n),\n          u = e.value.slice(n);\n      return {\n        result: a ? e.result.concat(r, a) : e.result,\n        value: u\n      };\n    }, {\n      result: \"\",\n      value: n\n    }).result.slice(0, r.length);\n    return e(i, r, c) ? i.concat(c) : i;\n  }\n\n  var v = l.reduce(function (e, r, t) {\n    var n = a[t] || \"\",\n        l = \"$1\" + n + \"$2\",\n        u = r + e.prevSlice + e.prevSeparator.length,\n        c = new RegExp(\"(.{\" + u + \"})(.)\");\n    return {\n      prevSeparator: n,\n      prevSlice: u,\n      value: e.value.replace(c, l)\n    };\n  }, {\n    prevSeparator: \"\",\n    prevSlice: 0,\n    value: n\n  }).value.slice(0, r.length);\n  return e(v, r, c) ? v.concat(c) : v;\n}\n\nexport default function (e, t) {\n  return void 0 === t ? function (t) {\n    return r(e, t);\n  } : r(e, t);\n}","map":{"version":3,"sources":["../src/index.ts"],"names":["shouldAppendLastSeparator","current","pattern","lastSeparator","length","endsWith","getFormattedString","value","cleanValue","String","replace","blockSizes","split","filter","Boolean","map","separators","firstSeparator","startsWith","reduce","acc","cur","index","curBlockSize","beforeSlice","slice","afterSlice","result","concat","res_1","curSeparator","curSlice","prevSlice","prevSeparator","curRegex","RegExp","res","undefined","curriedValue"],"mappings":"AAAA,SAASA,CAAT,CAAmCC,CAAnC,EAAoDC,CAApD,EAAqEC,CAArE,EAAqEA;AACnE,SAAOF,CAAAA,CAAQG,MAARH,GAAiB,CAAjBA,KAAuBC,CAAAA,CAAQE,MAA/BH,IAAyCC,CAAAA,CAAQG,QAARH,CAAiBC,CAAjBD,CAAhD;AAGF;;AAAA,SAASI,CAAT,CAA4BJ,CAA5B,EAA6CK,CAA7C,EAA6CA;AAC3C,MAAA,CAAKA,CAAL,EACE,OAAOA,CAAP;AAGF,MAAMC,CAAAA,GAAaC,MAAAA,CAAOF,CAAPE,CAAAA,CAAcC,OAAdD,CAAsB,iBAAtBA,EAAyC,EAAzCA,CAAnB;AAAA,MACME,CAAAA,GAAaT,CAAAA,CAChBU,KADgBV,CACV,iBADUA,EAEhBW,MAFgBX,CAETY,OAFSZ,EAGhBa,GAHgBb,CAGZ,UAAA,CAAA,EAAA;AAAK,WAAA,CAAA,CAAEE,MAAF;AAAEA,GAHKF,CADnB;AAAA,MAKMc,CAAAA,GAAad,CAAAA,CAAQU,KAARV,CAAc,gBAAdA,EAAgCW,MAAhCX,CAAuCY,OAAvCZ,CALnB;AAAA,MAMOe,CAAAA,GAAkBD,CAAAA,CAAAA,CAAAA,CANzB;AAAA,MAOMb,CAAAA,GAAgBa,CAAAA,CAAWA,CAAAA,CAAWZ,MAAXY,GAAoB,CAA/BA,CAPtB;;AASA,MAAId,CAAAA,CAAQgB,UAARhB,CAAmBe,CAAnBf,CAAJ,EAAwC;AACtC,QAkBM2B,CAAAA,GAlBcb,CAAAA,CAAWG,MAAXH,CAClB,UAACI,CAAD,EAAMC,CAAN,EAAWC,CAAX,EAAWA;AACT,UAAMC,CAAAA,GAAeZ,CAAAA,CAAWW,CAAXX,CAArB;AAAA,UACMa,CAAAA,GAAcJ,CAAAA,CAAIb,KAAJa,CAAUK,KAAVL,CAAgB,CAAhBA,EAAmBG,CAAnBH,CADpB;AAAA,UAEMM,CAAAA,GAAaN,CAAAA,CAAIb,KAAJa,CAAUK,KAAVL,CAAgBG,CAAhBH,CAFnB;AAKA,aAAO;AACLO,QAAAA,MAAAA,EAHiBH,CAAAA,GAAcJ,CAAAA,CAAIO,MAAJP,CAAWQ,MAAXR,CAAkBC,CAAlBD,EAAuBI,CAAvBJ,CAAdI,GAAoDJ,CAAAA,CAAIO,MAEpE;AAELpB,QAAAA,KAAAA,EAAOmB;AAFF,OAAP;AAESA,KATOV,EAYlB;AACEW,MAAAA,MAAAA,EAAQ,EADV;AAEEpB,MAAAA,KAAAA,EAAOC;AAFT,KAZkBQ,EAkBIW,MAlBJX,CAkBWS,KAlBXT,CAkBiB,CAlBjBA,EAkBoBd,CAAAA,CAAQE,MAlB5BY,CAApB;AAoBA,WAAIhB,CAAAA,CAA0B6B,CAA1B7B,EAA+BE,CAA/BF,EAAwCG,CAAxCH,CAAAA,GACK6B,CAAAA,CAAID,MAAJC,CAAW1B,CAAX0B,CADL7B,GAIG6B,CAJP;AAOF;;AAAA,MAqBMO,CAAAA,GArBczB,CAAAA,CAAWQ,MAAXR,CAClB,UAACS,CAAD,EAAMC,CAAN,EAAWC,CAAX,EAAWA;AACT,QAAMQ,CAAAA,GAAed,CAAAA,CAAWM,CAAXN,CAAAA,IAAqB,EAA1C;AAAA,QACMN,CAAAA,GAAU,OAAKoB,CAAL,GAAKA,IADrB;AAAA,QAEMC,CAAAA,GAAWV,CAAAA,GAAMD,CAAAA,CAAIY,SAAVX,GAAsBD,CAAAA,CAAIa,aAAJb,CAAkBhB,MAFzD;AAAA,QAGM8B,CAAAA,GAAW,IAAIC,MAAJ,CAAW,QAAMJ,CAAN,GAAMA,OAAjB,CAHjB;AAMA,WAAO;AACLE,MAAAA,aAAAA,EAAeH,CADV;AAELE,MAAAA,SAAAA,EAAWD,CAFN;AAGLxB,MAAAA,KAAAA,EALea,CAAAA,CAAIb,KAAJa,CAAUV,OAAVU,CAAkBc,CAAlBd,EAA4BV,CAA5BU;AAEV,KAAP;AAF6CV,GAN7BC,EAclB;AACEsB,IAAAA,aAAAA,EAAe,EADjB;AAEED,IAAAA,SAAAA,EAAW,CAFb;AAGEzB,IAAAA,KAAAA,EAAOC;AAHT,GAdkBG,EAqBIJ,KArBJI,CAqBUc,KArBVd,CAqBgB,CArBhBA,EAqBmBT,CAAAA,CAAQE,MArB3BO,CAApB;AAuBA,SAAIX,CAAAA,CAA0BoC,CAA1BpC,EAA+BE,CAA/BF,EAAwCG,CAAxCH,CAAAA,GACKoC,CAAAA,CAAIR,MAAJQ,CAAWjC,CAAXiC,CADLpC,GAIGoC,CAJP;AAIOA;;AAAAA,eAKT,UAA+BlC,CAA/B,EAAgDK,CAAhD,EAAgDA;AAC9C,SAAA,KAAiB8B,CAAjB,KAAO9B,CAAP,GACI,UAAC+B,CAAD,EAACA;AAAkC,WAAA,CAAA,CAAmBpC,CAAnB,EAA4BoC,CAA5B,CAAA;AAA4BA,GADnE,GAEIhC,CAAAA,CAAmBJ,CAAnBI,EAA4BC,CAA5BD,CAFJ;AAEgCC","sourcesContent":["function shouldAppendLastSeparator(current: string, pattern: string, lastSeparator: string) {\n  return current.length + 1 === pattern.length && pattern.endsWith(lastSeparator);\n}\n\nfunction getFormattedString(pattern: string, value?: string | number) {\n  if (!value) {\n    return value;\n  }\n\n  const cleanValue = String(value).replace(/[^\\da-zA-Z\\n|]/g, '');\n  const blockSizes = pattern\n    .split(/[^\\da-zA-Z\\n|]/g)\n    .filter(Boolean)\n    .map(b => b.length);\n  const separators = pattern.split(/[\\da-zA-Z\\n|]/g).filter(Boolean);\n  const [firstSeparator] = separators;\n  const lastSeparator = separators[separators.length - 1];\n\n  if (pattern.startsWith(firstSeparator)) {\n    const afterReduce = separators.reduce(\n      (acc, cur, index) => {\n        const curBlockSize = blockSizes[index];\n        const beforeSlice = acc.value.slice(0, curBlockSize);\n        const afterSlice = acc.value.slice(curBlockSize);\n        const nextResult = beforeSlice ? acc.result.concat(cur, beforeSlice) : acc.result;\n\n        return {\n          result: nextResult,\n          value: afterSlice,\n        };\n      },\n      {\n        result: '',\n        value: cleanValue,\n      }\n    );\n\n    const res = afterReduce.result.slice(0, pattern.length);\n\n    if (shouldAppendLastSeparator(res, pattern, lastSeparator)) {\n      return res.concat(lastSeparator);\n    }\n\n    return res;\n  }\n\n  const afterReduce = blockSizes.reduce(\n    (acc, cur, index) => {\n      const curSeparator = separators[index] || '';\n      const replace = `$1${curSeparator}$2`;\n      const curSlice = cur + acc.prevSlice + acc.prevSeparator.length;\n      const curRegex = new RegExp(`(.{${curSlice}})(.)`);\n      const curValue = acc.value.replace(curRegex, replace);\n\n      return {\n        prevSeparator: curSeparator,\n        prevSlice: curSlice,\n        value: curValue,\n      };\n    },\n    {\n      prevSeparator: '',\n      prevSlice: 0,\n      value: cleanValue,\n    }\n  );\n\n  const res = afterReduce.value.slice(0, pattern.length);\n\n  if (shouldAppendLastSeparator(res, pattern, lastSeparator)) {\n    return res.concat(lastSeparator);\n  }\n\n  return res;\n}\n\nfunction formatStringByPattern(pattern: string): (value?: string | number) => string;\nfunction formatStringByPattern(pattern: string, value: string | number): string;\nfunction formatStringByPattern(pattern: string, value?: string | number) {\n  return value === undefined\n    ? (curriedValue: string | number) => getFormattedString(pattern, curriedValue)\n    : getFormattedString(pattern, value);\n}\n\nexport default formatStringByPattern;\n"]},"metadata":{},"sourceType":"module"}